//
// TomÃ¡s Oliveira e Silva,  October 2024
//
// Arquiteturas de Alto Desempenho 2024/2025
//
// MD5 hash CUDA kernel code
//
// md5_cuda_kernel() --- each thread computes the MD5 hash of one message
//
// do not use this directy to search for DETI coins!
//

//
// needed stuff
//

typedef unsigned int u32_t;

#include "md5.h"

//
// the nvcc compiler stores x[] and state[] in registers (constant indices!)
//
// global thread number: n = threadIdx.x + blockDim.x * blockIdx.x
// global warp number: n >> 5
// warp thread number: n & 31
//

extern "C" __global__ __launch_bounds__(128,1) void cuda_md5_kernel(u32_t v1,u32_t v2,u32_t number_coins,u32_t *data_storage_device)
{
  u32_t n,a,b,c,d,coin[13u * number_coins],hash[4u*number_coins],state[4],x[16];
  n = (u32_t)threadIdx.x + (u32_t)blockDim.x * (u32_t)blockIdx.x;
  
  //
  // mandatory for a DETI coin
  //
  // 64 coins generated by every thread
  for( int i =0;i<number_coins; i++){

  coin[ 0+13u*i] = 0x49544544; // ITED
  coin[ 1+13u*i] = 0x696f6320; // ioc_ 
  coin[ 2+13u*i] = 0x7343206e; // sC_n
  coin[ 3+13u*i] = 0x30324341; // 02CA
  coin[ 4+13u*i] = 0x41203432; // A_42
  coin[ 5+13u*i] = 0x34314441; // 41DA
  coin[ 6+13u*i] = v1; 
  coin[ 7+13u*i] = v2;
  }

  for( int i =0;i<number_coins; i++){
    for (int offset = 8; offset <= 11; ++offset) {
        int index = offset + 13u * i;
        next_value_to_try(coin[index]);
        if ((coin[index] & 0xFF) == 0x7F) {
            next_value_to_try(coin[index]);
        }
}
# define C(c)         (c)
# define ROTATE(x,n)  (((x) << (n)) | ((x) >> (32 - (n))))
# define DATA(idx)    coin[idx] 
# define HASH(idx)    hash[idx]
# define STATE(idx)   state[idx]
# define X(idx)       x[idx]
        CUSTOM_MD5_CODE();
# undef C
# undef ROTATE
# undef DATA
# undef HASH
# undef STATE
# undef X
    u32_t idx = atomicAdd(&data_storage_device,13)
    if (hash[3]==0 && idx < 1024 -13){
      data_storage_device[idx]=coin
    }
  }


}
